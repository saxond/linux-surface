diff --git a/drivers/acpi/acpica/dsopcode.c b/drivers/acpi/acpica/dsopcode.c
index 10f32b62608e..7b2a4987f050 100644
--- a/drivers/acpi/acpica/dsopcode.c
+++ b/drivers/acpi/acpica/dsopcode.c
@@ -123,7 +123,7 @@ acpi_ds_init_buffer_field(u16 aml_opcode,
 
 		/* Offset is in bits, count is in bits */
 
-		field_flags = AML_FIELD_ACCESS_BYTE;
+		field_flags = AML_FIELD_ACCESS_BUFFER;
 		bit_offset = offset;
 		bit_count = (u32) length_desc->integer.value;
 
diff --git a/drivers/acpi/acpica/exfield.c b/drivers/acpi/acpica/exfield.c
index d3d2dbfba680..0b7f617a6e9b 100644
--- a/drivers/acpi/acpica/exfield.c
+++ b/drivers/acpi/acpica/exfield.c
@@ -109,6 +109,7 @@ acpi_ex_read_data_from_field(struct acpi_walk_state *walk_state,
 	union acpi_operand_object *buffer_desc;
 	void *buffer;
 	u32 buffer_length;
+	u8 field_flags;
 
 	ACPI_FUNCTION_TRACE_PTR(ex_read_data_from_field, obj_desc);
 
@@ -157,11 +158,16 @@ acpi_ex_read_data_from_field(struct acpi_walk_state *walk_state,
 	 * Note: Field.length is in bits.
 	 */
 	buffer_length =
-	    (acpi_size)ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->field.bit_length);
+	    (acpi_size)ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length);
+	field_flags = obj_desc->common_field.field_flags;
 
-	if (buffer_length > acpi_gbl_integer_byte_width) {
+	if (buffer_length > acpi_gbl_integer_byte_width ||
+	    (field_flags & AML_FIELD_ACCESS_TYPE_MASK) == AML_FIELD_ACCESS_BUFFER) {
 
-		/* Field is too large for an Integer, create a Buffer instead */
+		/*
+		 * Field is either too large for an Integer, or a actually of type
+		 * buffer, so create a Buffer.
+		 */
 
 		buffer_desc = acpi_ut_create_buffer_object(buffer_length);
 		if (!buffer_desc) {
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 1b67bb578f9f..0c1fc3655b5c 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -620,6 +620,103 @@ config THINKPAD_ACPI_HOTKEY_POLL
 	  If you are not sure, say Y here.  The driver enables polling only if
 	  it is strictly necessary to do so.
 
+config SURFACE_ACPI
+	depends on ACPI
+	tristate "Microsoft Surface ACPI/Platform Drivers"
+	---help---
+	  ACPI and platform drivers for Microsoft Surface devices.
+
+config SURFACE_ACPI_SSH
+	bool "Surface Serial Hub Driver"
+	depends on SURFACE_ACPI
+	depends on X86_INTEL_LPSS
+	depends on SERIAL_8250_DW
+	depends on SERIAL_8250_DMA
+	depends on SERIAL_DEV_CTRL_TTYPORT
+	select CRC_CCITT
+	default y
+	---help---
+	  Surface Serial Hub driver for 5th generation (or later) Microsoft
+	  Surface devices.
+
+	  This is the base driver for the embedded serial controller found on
+	  5th generation (and later) Microsoft Surface devices (e.g. Book 2,
+	  Laptop, Laptop 2, Pro 2017, Pro 6, ...). This driver itself only
+	  provides access to the embedded controller and subsequent drivers are
+	  required for the respective functionalities.
+
+	  If you have a 5th generation (or later) Microsoft Surface device, say
+	  Y or M here.
+
+config SURFACE_ACPI_SSH_DEBUG_DEVICE
+	bool "Surface Serial Hub Debug Device"
+	depends on SURFACE_ACPI_SSH
+	default n
+	---help---
+	  Debug device for direct communication with the embedded controller
+	  found on 5th generation (and later) Microsoft Surface devices (e.g.
+	  Book 2, Laptop, Laptop 2, Pro 2017, Pro 6, ...) via sysfs.
+
+	  If you are not sure, say N here.
+
+config SURFACE_ACPI_SAN
+	bool "Surface ACPI Notify Driver"
+	depends on SURFACE_ACPI_SSH
+	default y
+	---help---
+	  Surface ACPI Notify driver for 5th generation (or later) Microsoft
+	  Surface devices.
+
+	  This driver enables basic ACPI events and requests, such as battery
+	  status requests/events, thermal events, lid status, and possibly more,
+	  which would otherwise not work on these devices.
+
+	  If you are not sure, say Y here.
+
+config SURFACE_ACPI_VHF
+	bool "Surface Virtual HID Framework Driver"
+	depends on SURFACE_ACPI_SSH
+	depends on HID
+	default y
+	---help---
+	  Surface Virtual HID Framework driver for 5th generation (or later)
+	  Microsoft Surface devices.
+
+	  This driver provides support for the Microsoft Virtual HID framework,
+	  which is required for the Surface Laptop (1 and newer) keyboard.
+
+	  If you are not sure, say Y here.
+
+config SURFACE_ACPI_DTX
+	bool "Surface Detachment System (DTX) Driver"
+	depends on SURFACE_ACPI_SSH
+	depends on INPUT
+	default y
+	---help---
+	  Surface Detachment System (DTX) driver for the Microsoft Surface Book
+	  2. This driver provides support for proper detachment handling in
+	  user-space, status-events relating to the base and support for
+	  the safe-guard keeping the base attached when the discrete GPU
+	  contained in it is running via the special /dev/surface-dtx device.
+
+	  Also provides a standard input device to provide SW_TABLET_MODE events
+	  upon device mode change.
+
+	  If you are not sure, say Y here.
+
+config SURFACE_ACPI_SID
+	bool "Surface Platform Integration Driver"
+	depends on SURFACE_ACPI_SSH
+	default y
+	---help---
+	  Surface Platform Integration Driver for the Microsoft Surface Devices.
+	  Currently only supports the Surface Book 2. This driver provides suport
+	  for setting performance-modes via the perf_mode sysfs attribute.
+	  Performance-modes directly influence the fan-profile of the device,
+	  allowing to choose between higher performance or quieter operation.
+
+	  If you are not sure, say Y here.
+
 config SENSORS_HDAPS
 	tristate "Thinkpad Hard Drive Active Protection System (hdaps)"
 	depends on INPUT
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 415104033060..662e595ae13f 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -39,6 +39,7 @@ obj-$(CONFIG_TC1100_WMI)	+= tc1100-wmi.o
 obj-$(CONFIG_SONY_LAPTOP)	+= sony-laptop.o
 obj-$(CONFIG_IDEAPAD_LAPTOP)	+= ideapad-laptop.o
 obj-$(CONFIG_THINKPAD_ACPI)	+= thinkpad_acpi.o
+obj-$(CONFIG_SURFACE_ACPI)	+= surface_acpi.o
 obj-$(CONFIG_SENSORS_HDAPS)	+= hdaps.o
 obj-$(CONFIG_FUJITSU_LAPTOP)	+= fujitsu-laptop.o
 obj-$(CONFIG_FUJITSU_TABLET)	+= fujitsu-tablet.o
diff --git a/drivers/tty/serdev/core.c b/drivers/tty/serdev/core.c
index a0ac16ee6575..0dd242ff24d1 100644
--- a/drivers/tty/serdev/core.c
+++ b/drivers/tty/serdev/core.c
@@ -558,8 +558,7 @@ static acpi_status acpi_serdev_register_device(struct serdev_controller *ctrl,
 	struct serdev_device *serdev = NULL;
 	int err;
 
-	if (acpi_bus_get_status(adev) || !adev->status.present ||
-	    acpi_device_enumerated(adev))
+	if (acpi_bus_get_status(adev) || !adev->status.present)
 		return AE_OK;
 
 	serdev = serdev_device_alloc(ctrl);
@@ -582,6 +581,81 @@ static acpi_status acpi_serdev_register_device(struct serdev_controller *ctrl,
 	return AE_OK;
 }
 
+struct acpi_serdev_add_device_from_resource_ctx {
+	acpi_handle ctrl_handle;
+	acpi_handle device_handle;
+	struct serdev_controller *ctrl;
+	struct acpi_device *device;
+};
+
+static acpi_status
+acpi_serdev_add_device_from_resource(struct acpi_resource *resource, void *data)
+{
+	struct acpi_serdev_add_device_from_resource_ctx* ctx = data;
+	struct acpi_resource_source *ctrl_name;
+	acpi_handle ctrl_handle;
+	acpi_status status;
+
+	if (resource->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
+		return AE_OK;
+
+	if (resource->data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)
+		return AE_OK;
+
+	ctrl_name = &resource->data.common_serial_bus.resource_source;
+	if (ctrl_name->string_length == 0 || !ctrl_name->string_ptr) {
+		return AE_OK;
+	}
+
+	status = acpi_get_handle(ctx->device_handle, ctrl_name->string_ptr,
+				 &ctrl_handle);
+	if (ACPI_FAILURE(status)) {
+		return AE_OK;
+	}
+
+	if (ctrl_handle == ctx->ctrl_handle) {
+		return acpi_serdev_register_device(ctx->ctrl, ctx->device);
+	}
+
+	return AE_OK;
+}
+
+static acpi_status
+acpi_serdev_add_devices_from_resources(acpi_handle handle, u32 level,
+				       void *data, void **return_value)
+{
+	struct acpi_serdev_add_device_from_resource_ctx *ctx = data;
+	acpi_status status;
+
+	ctx->device_handle = handle;
+
+	status = acpi_bus_get_device(handle, &ctx->device);
+	if (status) return AE_OK;
+
+	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
+	                             acpi_serdev_add_device_from_resource,
+				     ctx);
+
+	if (status == AE_NOT_FOUND)
+		return AE_OK;		// not finding _CRS is not an error
+	else
+		return status;
+}
+
+static int
+acpi_serdev_register_devices_from_resources(acpi_handle handle,
+					    struct serdev_controller *ctrl)
+{
+	struct acpi_serdev_add_device_from_resource_ctx ctx = {
+		.ctrl = ctrl,
+		.ctrl_handle = handle,
+	};
+
+	return acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, 128,
+				   acpi_serdev_add_devices_from_resources,
+				   NULL, &ctx, NULL);
+}
+
 static acpi_status acpi_serdev_add_device(acpi_handle handle, u32 level,
 				       void *data, void **return_value)
 {
@@ -591,6 +665,9 @@ static acpi_status acpi_serdev_add_device(acpi_handle handle, u32 level,
 	if (acpi_bus_get_device(handle, &adev))
 		return AE_OK;
 
+	if (acpi_device_enumerated(adev))
+		return AE_OK;
+
 	return acpi_serdev_register_device(ctrl, adev);
 }
 
@@ -608,6 +685,15 @@ static int acpi_serdev_register_devices(struct serdev_controller *ctrl)
 	if (ACPI_FAILURE(status))
 		dev_dbg(&ctrl->dev, "failed to enumerate serdev slaves\n");
 
+	if (!ctrl->serdev) {
+		status = acpi_serdev_register_devices_from_resources(handle, ctrl);
+		if (ACPI_FAILURE(status)) {
+			dev_dbg(&ctrl->dev,
+			        "failed to register serdev slaves from resources: %x\n",
+				status);
+		}
+	}
+
 	if (!ctrl->serdev)
 		return -ENODEV;
 
